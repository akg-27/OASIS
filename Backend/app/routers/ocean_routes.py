# app/routers/ocean_routes.py
from fastapi import APIRouter, Query
from fastapi.responses import Response
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import pandas as pd
import io
from app.database import supabase

router = APIRouter(prefix="/ocean", tags=["Ocean Visualization"])


Y_PARAMETERS = [
    "dic", "mld", "pco2_original", "chl",
    "no3", "sss", "sst", "deviant_uncertainty"
]

X_OPTIONS = ["lat", "lon", "datetime"]

UNITS = {
    "dic": "milimole/m3",
    "mld": "m",
    "pco2_original": "micro_atm",
    "chl": "kg/m3",
    "no3": "milimole/m3",
    "sss": "PSU",
    "sst": "deg C",
    "deviant_uncertainty": "micro atm"
}

RANGE_LIMITS = {
    "dic": (1950, 2100),
    "mld": (0, 100),
    "pco2_original": (250, 550),
    "chl": (5e-8, 4e-7),
    "no3": (0.00, 0.06),
    "sss": (30, 40),
    "sst": (20, 35),
    "deviant_uncertainty": (0, 5)
}


def load_ocean_data():
    res = supabase.table("ocean_data").select("*").execute()
    if not res.data:
        return None
    df = pd.DataFrame(res.data)
    if "datetime" in df.columns:
        df["datetime"] = pd.to_datetime(df["datetime"], errors="coerce")
    return df


@router.get("/plot")
def generate_plot(
    plot_type: str = Query(..., enum=["line", "scatter"]),
    x: str = Query(..., enum=X_OPTIONS),
    y: str = Query(..., enum=Y_PARAMETERS),
    start_date: str | None = None,
    end_date: str | None = None
):
    df = load_ocean_data()
    if df is None:
        return {"error": "No ocean data available"}

    if x == "datetime":
        if start_date:
            df = df[df["datetime"] >= pd.to_datetime(start_date)]
        if end_date:
            df = df[df["datetime"] <= pd.to_datetime(end_date)]

    df = df[[x, y]].dropna()

    # ===============================
    # LIMIT: use only first 1000 rows
    # (no filtering, negatives allowed)
    # ===============================
    df = df.head(1000)

    if df.empty:
        return {"error": "No data available for this selection"}

    ymin, ymax = RANGE_LIMITS.get(y, (df[y].min(), df[y].max()))
    unit = UNITS.get(y, "")

    # ===========================
    # Stats including negatives
    # ===========================
    min_val = df[y].min()
    max_val = df[y].max()
    mean_val = df[y].mean()

    plt.figure(figsize=(12, 6), dpi=180)
    plt.style.use("seaborn-v0_8")
    ax = plt.gca()
    ax.set_facecolor("#f7f9fc")
    plt.grid(color="#d9d9d9", linestyle="--", linewidth=0.7, alpha=0.7)

    if plot_type == "line":
        plt.plot(
            df[x], df[y],
            linewidth=2.2,
            color="#2962FF",
            label=f"{y.upper()} ({unit})"
        )

    elif plot_type == "scatter":
        plt.scatter(
            df[x], df[y],
            s=45,
            color="#2962FF",
            edgecolor="#1a1a1a",
            alpha=0.85,
            label=f"{y.upper()} ({unit})"
        )

    plt.title(
        f"{plot_type.upper()} Plot of {y.upper()} vs {x.upper()}",
        fontsize=18,
        fontweight="bold",
        pad=20,
        color="#0a0a0a"
    )

    plt.xlabel(x.upper(), fontsize=14, fontweight="bold")
    plt.ylabel(f"{y.upper()} ({unit})", fontsize=14, fontweight="bold")
    plt.ylim(ymin, ymax)

    plt.legend(
        fontsize=12,
        loc="upper right",
        frameon=True,
        facecolor="#ffffff",
        edgecolor="#cccccc"
    )

    # ===========================
    # Stats box (negatives included)
    # ===========================
    plt.text(
        0.01, 0.98,
        f"Min: {min_val:.4f}\nMax: {max_val:.4f}\nAvg: {mean_val:.4f}",
        transform=plt.gca().transAxes,
        ha="left",
        va="top",
        fontsize=11,
        color="#000",
        bbox=dict(boxstyle="round,pad=0.3", facecolor="#ffffff", edgecolor="#bbbbbb")
    )

    plt.text(
        0.99, 0.01,
        "Generated by CMFRI Ocean Analytics",
        fontsize=10,
        color="#777777",
        ha="right",
        va="bottom",
        alpha=0.8,
        transform=plt.gca().transAxes
    )

    plt.tight_layout()

    buf = io.BytesIO()
    plt.savefig(buf, format="png", dpi=180)
    plt.close()
    buf.seek(0)

    return Response(content=buf.getvalue(), media_type="image/png")
