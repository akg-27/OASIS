# app/routers/ocean_routes.py
from fastapi import APIRouter, Query
from fastapi.responses import Response
from datetime import datetime
import matplotlib.pyplot as plt
import pandas as pd
import io
from app.database import supabase

router = APIRouter(prefix="/ocean", tags=["Ocean Visualization"])


# ============================
# VALID FIELDS
# ============================
Y_PARAMETERS = [
    "dic", "mld", "pco2_original", "chl",
    "no3", "sss", "sst", "deviant_uncertainty"
]

X_OPTIONS = ["lat", "lon", "datetime"]


# ============================
# UNITS (as per your dataset)
# ============================
UNITS = {
    "dic": "milimole/m3",
    "mld": "m",
    "pco2_original": "micro_atm",
    "chl": "kg/m3",
    "no3": "milimole/m3",
    "sss": "PSU",
    "sst": "deg C",
    "deviant_uncertainty": "micro atm"
}


# ============================
# RANGE LIMITS (scientific)
# ============================
RANGE_LIMITS = {
    "dic": (1950, 2100),
    "mld": (0, 100),
    "pco2_original": (250, 550),
    "chl": (5e-8, 4e-7),
    "no3": (0.00, 0.06),
    "sss": (30, 40),
    "sst": (20, 35),
    "deviant_uncertainty": (0, 5)
}


# ============================
# DB LOADER
# ============================
def load_ocean_data():
    res = supabase.table("ocean_data").select("*").execute()
    if not res.data:
        return None

    df = pd.DataFrame(res.data)

    # convert datetime
    if "datetime" in df.columns:
        df["datetime"] = pd.to_datetime(df["datetime"], errors="coerce")

    return df



# ============================
# MAIN PLOT ENDPOINT
# ============================
@router.get("/plot")
def generate_plot(
    plot_type: str = Query(..., enum=["line", "scatter", "bubble"]),
    x: str = Query(..., enum=X_OPTIONS),
    y: str = Query(..., enum=Y_PARAMETERS),
    start_date: str | None = None,
    end_date: str | None = None
):
    df = load_ocean_data()
    if df is None:
        return {"error": "No ocean data available"}

    # ----- Filter by date range -----
    if x == "datetime":
        if start_date:
            df = df[df["datetime"] >= pd.to_datetime(start_date)]
        if end_date:
            df = df[df["datetime"] <= pd.to_datetime(end_date)]

    # Keep only required columns
    df = df[[x, y]].dropna()

    if df.empty:
        return {"error": "No data available for selected parameters"}

    # ----- Prepare ranges -----
    ymin, ymax = RANGE_LIMITS.get(y, (df[y].min(), df[y].max()))
    unit = UNITS.get(y, "")

    # ----- Create plot -----
    plt.figure(figsize=(10, 5))
    plt.style.use("seaborn-v0_8")

    if plot_type == "line":
        plt.plot(df[x], df[y], linewidth=1.5)

    elif plot_type == "scatter":
        plt.scatter(df[x], df[y], s=25, alpha=0.7)

    
    plt.xlabel(x.upper())
    plt.ylabel(f"{y.upper()} ({unit})")
    plt.title(f"{plot_type.upper()} plot of {y.upper()} vs {x.upper()}")

    # Apply scientific range limits
    plt.ylim(ymin, ymax)

    plt.tight_layout()

    # ----- Return PNG -----
    buf = io.BytesIO()
    plt.savefig(buf, format="png", dpi=180)
    plt.close()
    buf.seek(0)

    return Response(content=buf.getvalue(), media_type="image/png")
